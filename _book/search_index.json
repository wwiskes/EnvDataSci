[["data-transformation.html", "5 Data Transformation 5.1 Data joins 5.2 Set Operations 5.3 Binding Rows and Columns 5.4 Pivotting data frames", " 5 Data Transformation The goal of this section is to continue where we started in the earlier chapter on data abstraction with dplyr to look at more transformational functions, and tidyr adds other tools like pivot tables. dplyr tools: joins: left_join, right_join, inner_join, full_join, semi_join, anti_join set operations: intersect, union, setdiff binding rows and columns: bind_cols, bind_rows tidyr tools: pivot tables: pivot_longer, pivot_wider The term data wrangling has been used for what were doing with these tools, and the relevant cheat sheet is actually called Data Wrangling https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf 5.1 Data joins To bring in variables from another data frame based on a common join field. There are multiple types of joins. Probably the most common is left_join since it starts from the data frame (or sf) you want to continue working with and bring in data from an additional source. Youll retain all records of the first data set. For any non-matches, NA is assigned. library(tidyverse) library(iGIScData) library(sf) csvPath &lt;- system.file(&quot;extdata&quot;, &quot;CA_MdInc.csv&quot;, package = &quot;iGIScData&quot;) income &lt;- read_csv(csvPath) %&gt;% select(trID, HHinc2016) %&gt;% mutate(HHinc2016 = as.numeric(HHinc2016), joinid = str_c(&quot;0&quot;, trID)) %&gt;% select(joinid, HHinc2016) census &lt;- BayAreaTracts %&gt;% left_join(income, by = c(&quot;FIPS&quot; = &quot;joinid&quot;)) %&gt;% select(FIPS, POP12_SQMI, POP2012, HHinc2016) head(census %&gt;% st_set_geometry(NULL)) ## FIPS POP12_SQMI POP2012 HHinc2016 ## 1 06001400100 1118.797 2976 177417 ## 2 06001400200 9130.435 2100 153125 ## 3 06001400300 11440.476 4805 85313 ## 4 06001400400 14573.077 3789 99539 ## 5 06001400500 15582.609 3584 83650 ## 6 06001400600 13516.667 1622 61597 Other joins are: right_join where you end up retaining all the rows of the second data set and NA is assigned to non-matches inner_join where you only retain records for matches full_join where records are retained for both sides, and NAs assigned to non-matches Right join example We need to join NCDC monthly climate data for all California weather stations to a selection of 82 stations that are in the Sierra. The monthly data has 12 rows (1/month) for each station The right_join gets all months for all stations, so we weed out the non-Sierra stations by removing NAs from a field only with Sierra station data sierra &lt;- right_join(sierraStations, CA_ClimateNormals, by=&quot;STATION&quot;) %&gt;% filter(!is.na(STATION_NA)) %&gt;% select(-STATION_NA) head(sierra %&gt;% filter(DATE == &quot;01&quot;) %&gt;% select(NAME, ELEVATION, `MLY-TAVG-NORMAL`), n=10) ## # A tibble: 10 x 3 ## NAME ELEVATION `MLY-TAVG-NORMAL` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GROVELAND 2, CA US 853. 5.6 ## 2 CANYON DAM, CA US 1390. 0.2 ## 3 KERN RIVER PH 3, CA US 824. 7.6 ## 4 DONNER MEMORIAL ST PARK, CA US 1810. -1.9 ## 5 BOWMAN DAM, CA US 1641. 3 ## 6 BRUSH CREEK RANGER STATION, CA US 1085. NA ## 7 GRANT GROVE, CA US 2012. 1.9 ## 8 LEE VINING, CA US 2072. -1.2 ## 9 OROVILLE MUNICIPAL AIRPORT, CA US 57.9 7.7 ## 10 LEMON COVE, CA US 156. 8.6 The exact same thing however could be accomplished with an inner_join and it doesnt required removing the NAs: sierraAlso &lt;- inner_join(sierraStations, CA_ClimateNormals, by=&quot;STATION&quot;) %&gt;% select(-STATION_NA) 5.2 Set Operations Set operations compare two data frames (or vectors) to handle observations or rows that are the same for each, or not the same. The three set methods are: dplyr::intersect(x,y) retains rows that appear in both x and y dplyr::union(x,y) retains rows that appear in either or both of x and y dplyr::setdiff(x,y) retains rows that appear in x but not in y squares &lt;- (1:10)^2 evens &lt;- seq(0,100,2) squares ## [1] 1 4 9 16 25 36 49 64 81 100 evens ## [1] 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 ## [20] 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 ## [39] 76 78 80 82 84 86 88 90 92 94 96 98 100 intersect(squares,evens) ## [1] 4 16 36 64 100 sort(union(squares,evens)) ## [1] 0 1 2 4 6 8 9 10 12 14 16 18 20 22 24 25 26 28 30 ## [20] 32 34 36 38 40 42 44 46 48 49 50 52 54 56 58 60 62 64 66 ## [39] 68 70 72 74 76 78 80 81 82 84 86 88 90 92 94 96 98 100 sort(setdiff(squares,evens)) ## [1] 1 9 25 49 81 5.3 Binding Rows and Columns These dplyr functions are similar to cbind and rbind in base R, but always creates data frames. For instance, cbind usually creates matrices, and make all vectors the same class. Note that in bind_cols, the order of data in rows must be the same. states &lt;- bind_cols(abb=state.abb, name=state.name, region=state.region, state.x77) head(states) ## # A tibble: 6 x 11 ## abb name region Population Income Illiteracy `Life Exp` Murder `HS Grad` ## &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AL Alab~ South 3615 3624 2.1 69.0 15.1 41.3 ## 2 AK Alas~ West 365 6315 1.5 69.3 11.3 66.7 ## 3 AZ Ariz~ West 2212 4530 1.8 70.6 7.8 58.1 ## 4 AR Arka~ South 2110 3378 1.9 70.7 10.1 39.9 ## 5 CA Cali~ West 21198 5114 1.1 71.7 10.3 62.6 ## 6 CO Colo~ West 2541 4884 0.7 72.1 6.8 63.9 ## # ... with 2 more variables: Frost &lt;dbl&gt;, Area &lt;dbl&gt; To compare, note that cbind converts numeric fields to character when any other field is character, and character fields are converted to character integers where there are any repeats, which would require manipulating them into factors: states &lt;- as_tibble(cbind(abb=state.abb, name=state.name, region=state.region, division=state.division, state.x77)) head(states) ## # A tibble: 6 x 12 ## abb name region division Population Income Illiteracy `Life Exp` Murder ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 AL Alab~ 2 4 3615 3624 2.1 69.05 15.1 ## 2 AK Alas~ 4 9 365 6315 1.5 69.31 11.3 ## 3 AZ Ariz~ 4 8 2212 4530 1.8 70.55 7.8 ## 4 AR Arka~ 2 5 2110 3378 1.9 70.66 10.1 ## 5 CA Cali~ 4 9 21198 5114 1.1 71.71 10.3 ## 6 CO Colo~ 4 8 2541 4884 0.7 72.06 6.8 ## # ... with 3 more variables: `HS Grad` &lt;chr&gt;, Frost &lt;chr&gt;, Area &lt;chr&gt; 5.4 Pivotting data frames Pivot tables are a popular tool in Excel, allowing you to transform your data to be more useful in a particular analysis. A common need to pivot is 2+ variables with the same data where the variable name should be a factor. Tidyr has pivot_wider and pivot_longer. pivot_wider pivots rows into variables. pivot_longer pivots variables into rows, creating factors. In our meadows study cross-section created by intersecting normalized difference vegetation index (NDVI) values from multispectral drone imagery with surveyed elevation and vegetation types (xeric, mesic, and hydric), we have fields NDVIgrowing from a July 2019 growing season and NDVIsenescent from a September 2020 dry season, but would like growing and senescent to be factors with a single NDVI variable. This is how we used pivot_longer to accomplish this, using data from the iGIScData data package: XSptsPheno &lt;- XSptsNDVI %&gt;% pivot_longer(cols = starts_with(&quot;NDVI&quot;), names_to = &quot;phenology&quot;, values_to = &quot;NDVI&quot;) %&gt;% mutate(phenology = str_sub(phenology, 5, str_length(phenology))) Then to do the opposite use pivot_wider: XSptsPheno %&gt;% pivot_wider(names_from = phenology, names_prefix = &quot;NDVI&quot;, values_from = NDVI) ## # A tibble: 29 x 6 ## DistNtoS elevation vegetation geometry NDVIgrowing NDVIsenescent ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 1510. Artemisia c(718649.456, 439~ 0.326 0.140 ## 2 16.7 1510. mixed gramin~ c(718649.4309, 43~ 0.627 0.259 ## 3 28.6 1510. mixed gramin~ c(718649.413, 439~ 0.686 0.329 ## 4 30.5 1510. mixed gramin~ c(718649.4101, 43~ 0.668 0.282 ## 5 31.1 1510. mixed gramin~ c(718649.4092, 43~ 0.655 0.266 ## 6 33.4 1510. mixed gramin~ c(718649.4058, 43~ 0.617 0.274 ## 7 35.6 1510. mixed gramin~ c(718649.4025, 43~ 0.623 0.275 ## 8 37 1510. mixed gramin~ c(718649.4004, 43~ 0.589 0.242 ## 9 74 1510. mixed gramin~ c(718649.3448, 43~ 0.641 0.325 ## 10 101 1510. mixed gramin~ c(718649.3042, 43~ 0.558 0.312 ## # ... with 19 more rows XSptsPheno ## # A tibble: 58 x 6 ## DistNtoS elevation vegetation geometry phenology NDVI ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0 1510. Artemisia c(718649.456, 4397466.714) growing 0.326 ## 2 0 1510. Artemisia c(718649.456, 4397466.714) senescent 0.140 ## 3 16.7 1510. mixed graminoid c(718649.4309, 4397450.07~ growing 0.627 ## 4 16.7 1510. mixed graminoid c(718649.4309, 4397450.07~ senescent 0.259 ## 5 28.6 1510. mixed graminoid c(718649.413, 4397438.222) growing 0.686 ## 6 28.6 1510. mixed graminoid c(718649.413, 4397438.222) senescent 0.329 ## 7 30.5 1510. mixed graminoid c(718649.4101, 4397436.33) growing 0.668 ## 8 30.5 1510. mixed graminoid c(718649.4101, 4397436.33) senescent 0.282 ## 9 31.1 1510. mixed graminoid c(718649.4092, 4397435.73~ growing 0.655 ## 10 31.1 1510. mixed graminoid c(718649.4092, 4397435.73~ senescent 0.266 ## # ... with 48 more rows XSptsPheno %&gt;% ggplot() + geom_point(aes(elevation, NDVI, shape=vegetation, color = phenology), size = 5) + geom_smooth(aes(elevation, NDVI, color = phenology), method=&quot;lm&quot;) Pivots turn out to be commonly useful. Runoff graphing from the Eucalyptus/Oak study also benefitted from a pivot_longer: eucoakrainfallrunoffTDR %&gt;% pivot_longer(cols = starts_with(&quot;runoffL&quot;), names_to = &quot;tree&quot;, values_to = &quot;runoffL&quot;) %&gt;% mutate(tree = str_sub(tree, str_length(tree)-2, str_length(tree))) %&gt;% ggplot() + geom_boxplot(aes(site, runoffL)) + facet_grid(tree ~ .) "]]
